# 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
> 클래스 내부에서 스스로 어떻게 사용하는지 모두 문서에 남겨야 하며, 문서화 한 것은 반드시 지켜야 한다. 

> 일부 메서드를 protected로 제공하자

> 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들자.

</br>


## 상속용 클래스를 만드려면
### 1. 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다. 
- 어떤 순서로 호출할지
- 각각의 호출 결과가 이어지는 처리에 어떤 영향을 미치는지
- 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다. 

### 2. @ImplSpec 자바독 도구 생성하여 작성하자. 
- 내부 구현 방식을 설명해야만 한다. 

### 3. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개햐아 할 수도 있다. 
- ex) removeRange 메서드
  - 실제로 List 구현체에서는 removeRange 메서드에 관심이 없지만, 하위 클래스에서 clear 메서드를 고성능으로 사용하기 위해 removeRange 메서드를 protected 형태로 제공한다. 
- protected 메서드의 수는 가능한 한 적어야 한다. 
  - 상속으로 얻는 이점을 없앨많큼 적게 노출하지는 말자.

### 4. 배포 전, 꼭 하위 클래스를 만들어 검증하자.
- 성능과 기능에 영원한 족쇄가 될 수 있으니

### 5. 상속용 클래스의 생성자는 직접적/간접적 둘다 재정의 가능 메서드를 호출해서는 안된다. 
- 이 규칙을 어기면 프로그램은 오작동
  - 상위클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되니까, 하위 클래스의 재정의 메서드가 하위 클래스의 생성자보다 먼저 호출된다. 

</br>

## 상속용 클래스를 시험하는 법
### 유일) 직접 하위 클래스를 만들어보는 것
- 꼭 필요한 protected 메서드를 체크하기 위해 하위 클래스를 만들어보자.
- 하위 클래스를 만들면서 전혀 사용하지 않는 protected 메서드는 private으로 바꾸자.
- 하위클래스 약 3개 정도 만들어보기
- 제 3자에게 만들라고 하기

</br>

## clone, readObject 재정의 메서드를 호출해서는 안된다. 
- 이들을 구현할때 따르는 제약도 생성자와 비슷하다. 


</br>

## 상속 금지 방법
상속용 클래스로 설계되지 않은 클래스는 상속을 금지하자

### 1. 클래스를 final로 선언

### 2. 모든 생성자를 private/package-private 선언. 및 public 정적 팩터리를 만들어주는 방법

</br>

## 기어코 상속을 꼭 허용해야겠다면?
### 1. 재정의 가능 메서드에 자기 사용 코드를 완벽하게 제거하자. 
- 재정의 가능 메서드를 자신의 본문 코드를 private 도우미 메서드로 옮기고, 도우미 메서드를 호출할 수 있도록 수정한다. 