# 아이템 28. 배열보다는 리스트를 사용하라

## 배열 vs 제네릭 차이

### 1. 공변 vs 불공변 (invariant)
> - 공변이란? 함께 변한다는 뜻이다.

- 배열은 공변이다.
  - `Sub`가 `Super`의 하위 타입이라면 배열 `Sub[]`는 배열 `Super[]`의 하위타입
- 제네릭은 불공변이다.
  - 서로 다른 타입 `Type1`, `Type2`가 있을 때, `List<Type1>`은 `List<Type2>`의 하위 타입도 상위타입도 아니다.
#### 문제점 예시
```java
// 런타임 실패
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다." //ArrayStoreException 발생
```
```java
// 컴파일 실패
List<Object> ol = new ArrayList<Long>(); // 호환되지 않는 타입이다.
ol.add("타입이 달라 넣을 수 없다.")
```
- 런타임보다 컴파일할때 발견되는 제네릭이 더 좋다.

### 2. 배열은 실체화(reify) 된다.
- 배열은 런타임에도 자신이 담기로 한 원소 타입을 인지하고 확인한다. (앞 예시 참조)
- 제네릭은 타입 정보가 런타임에는 소거된다.
  - 원소타입을 컴파일 타임에만 검사하며 런타임에는 타입 알 수 없다.
  - 레거시와 호환을 위해서다.
  - 즉, 런타임에는 `List<Integer>`는 단순히 `List`가 된다.
- `E`, `List<E>`, `List<String>`같은 타입을 소거되기 때문에 실체화 불가 타입(non-relifiable type)이라한다.
  - 실체화 될 수 있는 타입은 List<?> 같은 비한정적 매개타입뿐이다.

<br/>

## 제네릭 배열 만들지 못하는 이유는?

- 타입 안전하지 않기 때문이다.
- 허용한다면 컴파일러가 자동 생성 형변환 코드에서 런타임 ClassCastException 발생

<br/>

## 배열 `T[]`보다는 컬렉션 `List<T>`를 사용

```java
public class Chooser<T> {
    private final List<T> choiceList;

    public Chooser(Collection<T> choices) {
        choiceList = new ArrayList<>(choices);
    }

    public T choose() {
        Random rnd = ThreadLocalRandom.current();
        return choiceList.get(rnd.nextInt(choiceList.size()));
    }
}
```
- __배열, 제네릭을 섞어쓰다가 경고를 만나면, 가장 먼저 배열을 리스트로 대체해보자.__
- 런타임에 ClassCastException이 발생 안해서 가치있다.

<br/>

## 결론

- 배열
  - 공변, 실체화된다.
  - 런타임에는 타입 안전하지만 컴파일타임에는 아니다.
- 제네릭
  - 불공변, 타입정보가 소거된다.
  - 컴파일에는 타입 안전하지만 런타임에는 아니다.
