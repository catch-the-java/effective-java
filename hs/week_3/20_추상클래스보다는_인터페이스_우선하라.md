# 아이템20. 추상 클래스보다는 인터페이스를 우선하라.

## 차이
- 상속 : 단일 상속만 지원 => 새로운 타입 정의하는데 제약
- 인터페이스 : 다중 구현 가능

## 인터페이스 장점

##### 기존 클래스에 손쉽게 새로운 인터페이스 구현 가능하다.
- 기존 클래스에 추상 클래스를 넣는 것은 클래스 계층구조에 혼란을 일으켜 어렵다.

##### 믹스인(mixin) 정의에 좋다.
> - 믹스인이란?
>   - 믹스인을 구현한 클래스에 원래 주된 기능 외에도 특정 선택적 기능을 제공한다고 선언하는 효과
>    - ex) Comparable : 믹스인 인터페이스

- 기존 클래스에 덧씌우기 힘듬
- 상속은 두 부모 상속 못해

##### 계층구조가 없는 타입 프레임워크를 만들 수 있다.

- 타입을 계층적으로 구분하기 어려운 경우도 많다.
- 이때 추상클래스 사용하면 무수히 많은 조합 발생

##### 래퍼클래스와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단

- 추상클래스 상속으로 기능을 추가한 클래스는 깨지기 쉽고 활용도 낮음.


## 템플릿 메서드 패턴

- 인터페이스와 추상 골격 구현 클래스와 함께 제공하는 식으로 인터페이스와 추상 클래스의 장점을 모두 취함.
  - 인터페이스 : 타입 정의 + 필요시 디폴트 메서드
  - 추상클래스 : 나머지 메서드 구현

#### 관례
- 인터페이스 이름이 Interface면 골격 구현 클래스 이름은 AbstractInterface로 짓자.
  - ex) AbstractSet, AbstractMap

#### 골격 구현 장점
##### 인터페이스로 구현을 만드려는 프로그래머 일을 상당히 덜어준다.

```java
public class IntArrays {
    static List<Integer> intArrayAsList(int[] a) {
        Objects.requireNonNull(a);

        // 다이아몬드 연산자를 이렇게 사용하는 건 자바 9부터 가능하다.
        // 더 낮은 버전을 사용한다면 <Integer>로 수정하자.
        return new AbstractList<>() {
            @Override public Integer get(int i) {
                return a[i];  // 오토박싱(아이템 6)
            }

            @Override public Integer set(int i, Integer val) {
                int oldVal = a[i];
                a[i] = val;     // 오토언박싱
                return oldVal;  // 오토박싱
            }

            @Override public int size() {
                return a.length;
            }
        };
    }

    public static void main(String[] args) {
        int[] a = new int[10];
        for (int i = 0; i < a.length; i++)
            a[i] = i;

        List<Integer> list = intArrayAsList(a);
        Collections.shuffle(list);
        System.out.println(list);
    }
}
```
- 어댑터 패턴 : int 배열을 받아 Integer 인스턴스의 리스트 형태로 보여준다.
