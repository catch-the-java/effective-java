# 아이템18. 상속보다는 컴포지션을 사용하라.
> 여기서 논하는건 인터페이스 상속이 아닌 클래스가 다른 클래스를 확장하는 상속을 뜻함

## 상속의 위험성

- __메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.__
  - 상위 클래스가 어떻게 구현되느냐에 따라서 하위 클래스의 동작에 이상이 생길 수 있다.
  - 또 상위클래스는 릴리스마다 내부구현이 달라질 수 있다.

<br/>

### 하위 클래스가 깨지기 쉬운 이유

##### 1. 상위 클래스 내부 구현을 알 수가 없어 재정의시 원하지 않는 동작이 발생할 수 있다. (HashSet 예제의 핵심)
- 다른 부분을 사용하는 '자기사용(self use)' 여부는 내부 구현에 속해 모른다.
  - 예를들어 addAll()은 내부적으로 add()를 호출하는데 알 수 없어 count세기 중복연산같은 오작동 유발
- 여부를 안다고 해도 다음 릴리스에도 유지될지 알 수도 없다.


<br/>

##### 2. 상위 클레스에 새로운 메서드가 추가되었을때 위험할 수 있다.
- __예제 핵심__
  - 예를들어 특정 컬렉션에 모든 원소는 특정 조건을 만족해야한다고 하자.
  - 기존에 있는 상위 클래스의 삽입 메서드는 재정의하여 삽입 전 조건검사를 수행할 수 있다.
  - __하지만 만약 삽입 메서드가 상위클래스에 새로 추가된다면?__
      - 하위 클래스에서 재정의 하지 못하면 조건 검사를 못하니 '허용되지 않는' 원소가 추가될 수 있다.

<br/>

##### 3. 새로 추가된 상위 클레스 메소드가 하위 클래스에 이미 추가되었던 메서드와 시그니처가 같고 반환 타입이 다르다면?
- 컴파일 오류 발생한다.

<br/>

## 컴포지션

- 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조

#### 용어 정리
- 컴포지션(composition) : 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻
- 전달(fowarding) : 새 클래스의 인스턴스 메서드들은 기존 클래스(private 필드)의 대응하는 메서드를 호출해 그 결과 반환
- 전달 메서드(fowarding method) : 새 클래스의 메서드

#### 효과
- 기존 클래스 내부 구현 방식 영향 벗어남.
  - (근데 이걸 사용하는데 내부구현 영향을 벗어날수가 있나..?)
- 기존 클래스에 새로운 메서드가 추가되도 영향 받지 않는다.
