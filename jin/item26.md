# Item 26 로 타입은 사용하지 말라

### 용어정리

제네릭 클래스(제네릭 인터페이스) - 클래스와 인터페이스 선언에 타입 매개변수가 쓰이는 경우 이러한 명칭을 사용. 제네릭 클래스와 제네릭 인터페이스를 통틀어서 제네릭 타입이라고 부른다.

로 타입 - 제네릭 타입에서 매개변수를 전혀 사용하지 않을 때를 의미한다.

### 예시

List 를 만들때에 List\<E>라고 가정했을때 E가 __매개변수화 타입__ 이며 단순히 List로 냅두면 로 타입이다.



하지만 매개변수화 타입을 지정해주지 않은 로타입을 사용하는 방법은 좋지 않은 방법이다. 로타입을 시해서는 안되는 이유를 알아보자.



### 사용해서 안되는 이유

1. 타입 안정성 확보 불가

```java
private final Collection stamps = ...;
stamps.add(new Coin());//unchecked warning을 발생시킨다.
```

위와 같은 경우 Stamp타입만을 넣기를 원하였으나 Coin 타입으 들어갔다. 넣을때는 문제가 되지 않지만.

```java
for (Iterator i = stamps.iterator(); i.hasNext();) {
  Stamp stamp = (Stamp) i.next();//ClassCastException 발생
  ctamp.cancel();
}
```

꺼낼때에는 형변환을 해줄 때에 문제가 발생할 수 있다 따라서.

```java
private final Collection<Stamp> stamps = ...;
```

과 같이 매개변수화 타입을 선언해줌으로서 타입 안정성을 높여줄 수 있다.

2. 로 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃게 된다.

자바가 로타입이라는 것을 남겨놓은 이유는 과거 제네릭이 없던 시절의 코드와 호환성을 맞춰주기 위함이다. 따라서 과거 호환성을 맞추기 위함이 아니면 쓸 이유가 없다.

다만 List\<Object>와 같이 선언하는 것은 괜찮은데, 그 이유는 컴파일러와 개발자에게 모든 타입을 허용한다는 것을 알릴 수 있기 때문이다.

하지만 우리는 어떤 것이 들어올지 모르는 파라메터를 받고싶을 수 있다. 다음 코드를 보자.

```java
static int numElementsInCommon(Set s1, Set s2) {
  int result = 0;
  for (Object o1 : s1) {
    if(s2.contains(o1))
      result++;
  }
  return result;
}
```

위 방식은 잘 동작하긴 하겠지만 로타입을 사용하였다. 따라서 이것을 __와일드카드 타입__을 이용하여 다시 작성해보자.

(추가적으로 이야기 하지면 와일드타입에서도 extends 키워드를 이용하여 들어올수 있는 타입의 형태를 제한시켜주는 것이 더 좋다.)

```java
static int numElementsInCommon(Set<?> s1, Set<?> s2) {...}
```

이 두가지 방식의 차이는 로타입은 안정적이지 않고 와일드카드 타입은 안정적이다는 것이다.

```java
Collection<?> nums
```

위 코드는 null을 제외한 어떠한 원소도 집어넣을 수 없으며 넣으려고 한다면 오류를 발생시킨다. 이 방식이 싫다면 뒤에 나오는 item30, 31을 사용하면 된다.(?)



### 예외사항

1. Class 리터럴에는 로 타입을 써야한다. 예를들어 List.class는 가능하지만 List\<E>.class는 허용하지 않는다.
2. instanceof 연산자와 관련이 있다. 런타임에는 제네릭 타입의 정보가 지워지기 때문에 비한정적 와일드 카드를 제외하고는 매개변수화 타입을 지정할 수 없다. 또한, 로타입이건 비한정적 와일드 카드를 사용하던 동일하게 동작한다.



책에 표로 용어들이 정리되어 있으니 참조필수

